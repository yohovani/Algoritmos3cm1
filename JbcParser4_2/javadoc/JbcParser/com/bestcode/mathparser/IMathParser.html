<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Sun Feb 15 00:12:54 GMT 2015 -->
<TITLE>
IMathParser (JavaDoc of the JbcParser - The Mathematical Expression Parser for Java project)
</TITLE>

<META NAME="keywords" CONTENT="com.bestcode.mathparser.IMathParser interface">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="IMathParser (JavaDoc of the JbcParser - The Mathematical Expression Parser for Java project)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../com/bestcode/mathparser/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<A HREF="#main"><FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/bestcode/mathparser/IFunction.html" title="interface in com.bestcode.mathparser"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/bestcode/mathparser/IParameter.html" title="interface in com.bestcode.mathparser"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?com/bestcode/mathparser/IMathParser.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="IMathParser.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<A NAME="main"></A>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.bestcode.mathparser</FONT>
<BR>
Interface IMathParser</H2>
<HR>
<DL>
<DT><PRE>public interface <B>IMathParser</B></DL>
</PRE>

<P>
IMathParser interface provides access to an implementation of the math parser
  algorithm. MathParserFactory.create() can be used to get a pointer to this interface.
  An instance of IMathParser is not thread safe. Do not share the same instance between
  threads. Create a separate instance for each thread or do your own synchronization in
  the way your application logic requires.
  <p>
  You can create a parser using MathParserFactory.create();
  This will return you a IMathParser.
  You can set the expression to parse using IMathParser.setExpression(String);
  And you can get the result using double IMathParser.getValue();
  </p>
<P>

<P>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#createConstant(java.lang.String, double)">createConstant</A></B>(java.lang.String&nbsp;constName,
               double&nbsp;constValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a variable whose value is constant and cannot be changed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#createDefaultFuncs()">createDefaultFuncs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;createDefaultFuncs method creates some predefined functions in the parser's list of functions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#createDefaultVars()">createDefaultVars</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X, Y and PI variables are predefined and can be immediately used in the expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#createFunc(java.lang.String, com.bestcode.mathparser.IFunction)">createFunc</A></B>(java.lang.String&nbsp;newFuncName,
           <A HREF="../../../com/bestcode/mathparser/IFunction.html" title="interface in com.bestcode.mathparser">IFunction</A>&nbsp;funcAddr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;createFunc method creates a new function that takes n number of parameters in
  the parser's list of functions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#createVar(java.lang.String, double)">createVar</A></B>(java.lang.String&nbsp;varName,
          double&nbsp;varValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same as setVariable(String, double);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#deleteAllFuncs()">deleteAllFuncs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteAllFuncs method deletes all variables from the list of available functions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#deleteAllVars()">deleteAllVars</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeleteAllVars method deletes all variables from the list of available variables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#deleteFunc(java.lang.String)">deleteFunc</A></B>(java.lang.String&nbsp;funcName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deleteFunc method deletes an existing function from the list of available functions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#deleteVar(java.lang.String)">deleteVar</A></B>(java.lang.String&nbsp;varName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deleteVar method deletes an existing variable from the list of available variables.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#evaluate()">evaluate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evaluates the expression and returns the result of it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#freeParseTree()">freeParseTree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FreeParseTree can be explicitly called to free the resources taken by the
  allocated Parse tree when an expression is parsed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#getExpression()">getExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please see setExpression() method to read about Expression property.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#getFunctions()">getFunctions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an array of functions declared for this parser.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Locale</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#getLocale()">getLocale</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the locale of this parser instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#getOptimizationOn()">getOptimizationOn</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set OptimizationOn to let the bcParser component evaluate constant expressions
  at parse time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#getValue()">getValue</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Value property (getValue() method) is an intuitive way of retrieving the value of the input expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#getVariable(java.lang.String)">getVariable</A></B>(java.lang.String&nbsp;varName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variable property is a way to set and get variable values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/bestcode/mathparser/IVariableResolver.html" title="interface in com.bestcode.mathparser">IVariableResolver</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#getVariableResolver()">getVariableResolver</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#getVariables()">getVariables</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the list of variables as an array of strings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#GetVariablesUsed()">GetVariablesUsed</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the list of variables used in the current expression as an array of Strings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#getX()">getX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X property represents the X variable used in the mathematical expression which
  was input to be evaluated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#getY()">getY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y property represents the Y variable used in the mathematical expression which
  was input to be evaluated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#isConstant(java.lang.String)">isConstant</A></B>(java.lang.String&nbsp;constName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if a constant with the name 'constName' is defined.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#isFunction(java.lang.String)">isFunction</A></B>(java.lang.String&nbsp;funcName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if a function with the name 'funcName' is present in the current functions list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#isFuncUsed(java.lang.String)">isFuncUsed</A></B>(java.lang.String&nbsp;funcName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if a function with the name 'funcName' is used in the current expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#isVariable(java.lang.String)">isVariable</A></B>(java.lang.String&nbsp;varName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if a variable with the name 'varName' is present in the current 
  variables list as a variable or constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#isVariableUsed(java.lang.String)">isVariableUsed</A></B>(java.lang.String&nbsp;varName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if a variable with the name 'varName' is used in the current expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#optimize()">optimize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Optimizes the parse tree by finding branches that evaluate to a constant and
  replacing them with a leaf representing the constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#parse()">parse</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses the expression and forms a parse tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#setExpression(java.lang.String)">setExpression</A></B>(java.lang.String&nbsp;newVal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression property represents the mathematical expression which is input to be evaluated by the user.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#setLocale(java.util.Locale)">setLocale</A></B>(java.util.Locale&nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the locale for the parser to use while constructing messages.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#setOptimizationOn(boolean)">setOptimizationOn</A></B>(boolean&nbsp;newVal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set OptimizationOn to let the bcParser component evaluate constant expressions
  at parse time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#setVariable(java.lang.String, double)">setVariable</A></B>(java.lang.String&nbsp;varName,
            double&nbsp;newVal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variable property is a way to set and get variable values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#setVariableResolver(com.bestcode.mathparser.IVariableResolver)">setVariableResolver</A></B>(<A HREF="../../../com/bestcode/mathparser/IVariableResolver.html" title="interface in com.bestcode.mathparser">IVariableResolver</A>&nbsp;variableResolver)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the IVariableResolver for this parser instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#setX(double)">setX</A></B>(double&nbsp;newVal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X property represents the X variable used in the mathematical expression which
  was input to be evaluated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/bestcode/mathparser/IMathParser.html#setY(double)">setY</A></B>(double&nbsp;newVal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y property represents the Y variable used in the mathematical expression which
  was input to be evaluated.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getExpression()"><!-- --></A><H3>
getExpression</H3>
<PRE>
java.lang.String <B>getExpression</B>()</PRE>
<DL>
<DD>Please see setExpression() method to read about Expression property.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setExpression(java.lang.String)"><!-- --></A><H3>
setExpression</H3>
<PRE>
void <B>setExpression</B>(java.lang.String&nbsp;newVal)</PRE>
<DL>
<DD>Expression property represents the mathematical expression which is input to be evaluated by the user.

  The expression can contain variables such as X, Y, T, HEIGHT, WEIGHT and so on.
  Expression can also contain functions that take one parameter, or two parameters.
  Variable and Function names are not case sensitive.
  <br><br>
  When Expression is assigned a value, it becomes 'dirty' and further attempt to
  evaluate its value will require it to be parsed. But once it is parsed,
  and a parse tree representing the expression is formed, it won't be parsed again,
  until it is assignd a new string. Instead, the parse tree will be used to retrieve
  current results as the values of variables change.
  <br><br>
  X, Y and PI variables are predefined and can be immediately used in the expression.
  CreateVar method can be used to add user variables.
  <br><br>
  Predefined functions that take one parameter are:
  <br><br>
  SQR: Square function which can be used as SQR(X)
  <br><br>
  SIN: Sinus function which can be used as SIN(X), X is a real-type expression.
  Sin returns the sine of the angle X in radians.
  <br><br>
  COS: Cosinus function which can be used as COS(X), X is a real-type expression.
  COS returns the cosine of the angle X in radians.
  <br><br>
  ATAN: ArcTangent function which can be used as ATAN(X)
  <br><br>
  SINH: Sinus Hyperbolic function which can be used as SINH(X)
  <br><br>
  COSH: Cosinus Hyperbolic function which can be used as COSH(X)
  <br><br>
  COTAN: which can be used as COTAN(X)
  <br><br>
  TAN: which can be used as TAN(X)
  <br><br>
  EXP: which can be used as EXP(X)
  <br><br>
  LN: natural log, which can be used as LN(X)
  <br><br>
  LOG: 10 based log, which can be used as LOG(X)
  <br><br>
  SQRT: which can be used as SQRT(X)
  <br><br>
  ABS: absolute value, which can be used as ABS(X)
  <br><br>
  SIGN: SIGN(X) returns -1 if X<0; +1 if X>0, 0 if X=0; it can be used as SQR(X)
  <br><br>
  TRUNC: Discards the fractional part of a number. e.g. TRUNC(-3.2) is -3, TRUNC(3.2) is 3.
  <br><br>
  CEIL: CEIL(-3.2) = -3, CEIL(3.2) = 4
  <br><br>
  FLOOR: FLOOR(-3.2) = -4, FLOOR(3.2) = 3
  <br><br>
  RANDOM:
  <br>
  RND(X) generates a random INTEGER number such that 0 <= Result < int(X).
  If X is negative, then result is int(X) < Result <= 0.
  <br><br>
  RANDOM(X) generates a random floating point number such that 0 <= Result < X.
  If X is negative, then result is X < Result <= 0.
  <br><br>
  Predefined functions that take two parameters are:
  <br><br>
  INTPOW: The INTPOW function raises Base to an integral power. INTPOW(2, 3) = 8.
  Note that result of INTPOW(2, 3.4) = 8 as well.
  <br><br>
  POW: The Power function raises Base to any power. For fractional exponents or
  exponents greater than MaxInt, Base must be greater than 0.
  <br><br>
  LOGN: The LogN function returns the log base N of X. Example: LOGN(10, 100) = 2
  <br><br>
  MIN: MIN(2, 3) is 2.
  <br><br>
  MAX: MAX(2, 3) is 3.
  <br><br>
  MOD: MOD(x,y) function implements the Java % (modulus) operator.
  <br><br>
  Predefined functions that take three parameters are:
  <br><br>
  IF:  The IF(b, case1, case2) function provides branching capability.
  If b is not 0, then it returns case1, else it returns case2.
  Behavior is similar to Java's: <b>return b ? case1 : case2;</b><br>
  If b==0 then case1 will not be evaluated, and vice versa.
  Example: IF(HEIGHT, 3/HEIGHT, 3) will make sure 3/HEIGHT does not cause division by zero.
  <br><br>

  User functions can be added using createFunc method.
  Functions and Variables can be deleted using DeleteVar, DeleteFunc,
  DeleteAllVars, DeleteAllFuncs methods.
  <br><br>

        Supported operators are +,-,*,/,^,% (integer division), =(equals),&(and),|(or),!(not), &lt;&gt;(not equals), &lt;=(less than or equals), &gt;=(greater than or equals)
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getValue()"><!-- --></A><H3>
getValue</H3>
<PRE>
double <B>getValue</B>()
                throws java.lang.Exception</PRE>
<DL>
<DD>Value property (getValue() method) is an intuitive way of retrieving the value of the input expression.
  Value property is a read only property which is in fact just an alias for the Evaluate method.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getVariable(java.lang.String)"><!-- --></A><H3>
getVariable</H3>
<PRE>
double <B>getVariable</B>(java.lang.String&nbsp;varName)
                   throws java.lang.Exception</PRE>
<DL>
<DD>Variable property is a way to set and get variable values.
  Throws Exception if the variable does not exist.
  Variable name is not case sensitive.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setVariable(java.lang.String, double)"><!-- --></A><H3>
setVariable</H3>
<PRE>
void <B>setVariable</B>(java.lang.String&nbsp;varName,
                 double&nbsp;newVal)
                 throws java.lang.Exception</PRE>
<DL>
<DD>Variable property is a way to set and get variable values.
  setVariable function creates the variable if the variable does not exist.
  Variable name is not case sensitive. Throws exception if the variable needs
  to be created and the name is not a valid variable name. createVar is just an
  alias for this method.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getX()"><!-- --></A><H3>
getX</H3>
<PRE>
double <B>getX</B>()
            throws java.lang.Exception</PRE>
<DL>
<DD>X property represents the X variable used in the mathematical expression which
  was input to be evaluated. You can set the X variable to a numeric value and
  call the Parse method (or Value property) to retrieve the new result of the expression.
  X variable is created by default for the convenience of the user.
  Additional variables can be added by using the CreateVar method.
  Variable names are case insensitive.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setX(double)"><!-- --></A><H3>
setX</H3>
<PRE>
void <B>setX</B>(double&nbsp;newVal)</PRE>
<DL>
<DD>X property represents the X variable used in the mathematical expression which
  was input to be evaluated. You can set the X variable to a numeric value and
  call the Parse method (or Value property) to retrieve the new result of the expression.
  X variable is created by default for the convenience of the user.
  Additional variables can be added by using the CreateVar method.
  Variable names are case insensitive.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getY()"><!-- --></A><H3>
getY</H3>
<PRE>
double <B>getY</B>()
            throws java.lang.Exception</PRE>
<DL>
<DD>Y property represents the Y variable used in the mathematical expression which
  was input to be evaluated. You can set the Y variable to a numeric value and
  call the Parse method (or Value property) to retrieve the new result of the expression.
  Y variable is created by default for the convenience of the user.
  Additional variables can be added by using the CreateVar method.
  Variable names are case insensitive.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setY(double)"><!-- --></A><H3>
setY</H3>
<PRE>
void <B>setY</B>(double&nbsp;newVal)</PRE>
<DL>
<DD>Y property represents the Y variable used in the mathematical expression which
  was input to be evaluated. You can set the Y variable to a numeric value and
  call the Parse method (or Value property) to retrieve the new result of the expression.
  Y variable is created by default for the convenience of the user.
  Additional variables can be added by using the CreateVar method.
  Variable names are case insensitive.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getOptimizationOn()"><!-- --></A><H3>
getOptimizationOn</H3>
<PRE>
boolean <B>getOptimizationOn</B>()</PRE>
<DL>
<DD>Set OptimizationOn to let the bcParser component evaluate constant expressions
  at parse time. The optimized parse tree will enhance subsequant evaluation
  operations, though initial parsing will be slower.
  <br><br>
  Optimization is good if you are going to parse once and evaluate the same
  expression many many times with different variable values.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOptimizationOn(boolean)"><!-- --></A><H3>
setOptimizationOn</H3>
<PRE>
void <B>setOptimizationOn</B>(boolean&nbsp;newVal)</PRE>
<DL>
<DD>Set OptimizationOn to let the bcParser component evaluate constant expressions
  at parse time. The optimized parse tree will enhance subsequant evaluation
  operations, though initial parsing will be slower.
  <br><br>
  Optimization is good if you are going to parse once and evaluate the same
  expression many many times with different variable values.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getVariableResolver()"><!-- --></A><H3>
getVariableResolver</H3>
<PRE>
<A HREF="../../../com/bestcode/mathparser/IVariableResolver.html" title="interface in com.bestcode.mathparser">IVariableResolver</A> <B>getVariableResolver</B>()</PRE>
<DL>
<DD><DL>

<DT><B>Returns:</B><DD>current IVariableResolver, null if not set before.<DT><B>See Also:</B><DD><A HREF="../../../com/bestcode/mathparser/IVariableResolver.html" title="interface in com.bestcode.mathparser"><CODE>IVariableResolver</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setVariableResolver(com.bestcode.mathparser.IVariableResolver)"><!-- --></A><H3>
setVariableResolver</H3>
<PRE>
void <B>setVariableResolver</B>(<A HREF="../../../com/bestcode/mathparser/IVariableResolver.html" title="interface in com.bestcode.mathparser">IVariableResolver</A>&nbsp;variableResolver)</PRE>
<DL>
<DD>Set the IVariableResolver for this parser instance.
 IVariableResolver is used to resolve variable values at evaluation time when they are not predefined.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>variableResolver</CODE> - - user defined IVariableResolver to use to return the values of undefined variables.<DT><B>See Also:</B><DD><A HREF="../../../com/bestcode/mathparser/IVariableResolver.html" title="interface in com.bestcode.mathparser"><CODE>IVariableResolver</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="evaluate()"><!-- --></A><H3>
evaluate</H3>
<PRE>
double <B>evaluate</B>()
                throws java.lang.Exception</PRE>
<DL>
<DD>Evaluates the expression and returns the result of it. If it cannot be parsed or
  evaluated then this method throws Exception.
  <br><br>
  Calling this method is identical to calling getValue()
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parse()"><!-- --></A><H3>
parse</H3>
<PRE>
void <B>parse</B>()
           throws java.lang.Exception</PRE>
<DL>
<DD>Parses the expression and forms a parse tree. Throws Exception if it cannot parse.
  Upon successful completion of parsing, it will set the Dirty flag to false, so that
  unless the expression is changed or variables and functions added or removed,
  expression does not need to be re-parsed. Users may want to call the parse method
  directly to check the validity of an input expression using a try-except block.
  <br><br>
  If OptimizationOn property is true, Parse method will optimize the parse tree by
  evaluating constant branches of the parse tree at that moment, so that Evaluate
  function will run faster.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="createVar(java.lang.String, double)"><!-- --></A><H3>
createVar</H3>
<PRE>
void <B>createVar</B>(java.lang.String&nbsp;varName,
               double&nbsp;varValue)
               throws java.lang.Exception</PRE>
<DL>
<DD>Same as setVariable(String, double);
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="createConstant(java.lang.String, double)"><!-- --></A><H3>
createConstant</H3>
<PRE>
void <B>createConstant</B>(java.lang.String&nbsp;constName,
                    double&nbsp;constValue)
                    throws java.lang.Exception</PRE>
<DL>
<DD>Creates a variable whose value is constant and cannot be changed.
 Using constants where possible enables the optimizer recognize 
 constant branches and simplify them into single constant nodes to improve
 evaluation performance.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>constName</CODE> - <DD><CODE>constValue</CODE> - 
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="createFunc(java.lang.String, com.bestcode.mathparser.IFunction)"><!-- --></A><H3>
createFunc</H3>
<PRE>
void <B>createFunc</B>(java.lang.String&nbsp;newFuncName,
                <A HREF="../../../com/bestcode/mathparser/IFunction.html" title="interface in com.bestcode.mathparser">IFunction</A>&nbsp;funcAddr)
                throws java.lang.Exception</PRE>
<DL>
<DD>createFunc method creates a new function that takes n number of parameters in
  the parser's list of functions. If the function name already exists, then 
  createFunc throws Exception.
  Function name is not case sensitive.
  <br><br>
  The second parameter is a reference to an implementation of the handler interface:
  <br><br>
  interface IFunction {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;     public double run(IParameter[] parameters);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;     public int getNumberOfParams();<br>
  }
  <br><br>
  While evaluation of the expression, when the registered function name is
  encountered, the user supplied IFunction.run(IParameter[]) will be called.
  <br><br>
  This event handler ( IFunction.run(IParameter[]) )
  will need to return a result (representing the value of the function)
  based on the parameters passed as an array of double values.
  <br><br>
  The number of parameters that this newFuncName function will take is determined by 
  the IFunction funcAddr parameter's  IFunction.getNumberOfParams() method.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultFuncs()"><!-- --></A><H3>
createDefaultFuncs</H3>
<PRE>
void <B>createDefaultFuncs</B>()
                        throws java.lang.Exception</PRE>
<DL>
<DD>createDefaultFuncs method creates some predefined functions in the parser's list of functions.
  <br><br>
  Predefined functions that take one parameter are:
  <br><br>
  SQR: Square function which can be used as SQR(X)
  <br><br>
  SIN: Sinus function which can be used as SIN(X), X is a real-type expression. Sin returns the sine of the angle X in radians.
  <br><br>
  COS: Cosinus function which can be used as COS(X), X is a real-type expression. COS returns the cosine of the angle X in radians.
  <br><br>
  ATAN: ArcTangent function which can be used as ATAN(X)
  <br><br>
  SINH: Sinus Hyperbolic function which can be used as SINH(X)
  <br><br>
  COSH: Cosinus Hyperbolic function which can be used as COSH(X)
  <br><br>
  COTAN: which can be used as COTAN(X)
  <br><br>
  TAN: which can be used as TAN(X)
  <br><br>
  EXP: which can be used as EXP(X)
  <br><br>
  LN: natural log, which can be used as LN(X)
  <br><br>
  LOG: 10 based log, which can be used as LOG(X)
  <br><br>
  SQRT: which can be used as SQRT(X)
  <br><br>
  ABS: absolute value, which can be used as ABS(X)
  <br><br>
  SIGN: SIGN(X) returns -1 if X<0; +1 if X>0, 0 if X=0; it can be used as SQR(X)
  <br><br>
  TRUNC: Discards the fractional part of a number. e.g. TRUNC(-3.2) is -3, TRUNC(3.2) is 3.
  <br><br>
  CEIL: CEIL(-3.2) = 3, CEIL(3.2) = 4
  <br><br>
  FLOOR: FLOOR(-3.2) = -4, FLOOR(3.2) = 3
  <br><br>
  RANDOM:
  <br>
  RND(X) generates a random INTEGER number such that 0 <= Result < int(X).
  <br><br>
  RANDOM(X) generates a random floating point number such that 0 <= Result < X.
  <br><br>
  Predefined functions that take two parameters are:
  <br><br>
  INTPOW: The INTPOW function raises Base to an integral power. INTPOW(2, 3) = 8. Note that result of INTPOW(2, 3.4) = 8 as well.
  <br><br>
  POW: The Power function raises Base to any power. For fractional exponents or exponents greater than MaxInt, Base must be greater than 0.
  <br><br>
  LOGN: The LogN function returns the log base N of X. Example: LOGN(10, 100) = 2
  <br><br>
  MIN: MIN(2, 3) is 2.
  <br><br>
  MAX: MAX(2, 3) is 3.
  <br><br>
  MOD: MOD(x,y) function implements the Java % (modulus) operator.
  <br><br>
  Predefined functions that take three parameters are:
  <br><br>
  IF:  The IF(b, case1, case2) function provides branching capability.
  If b is not 0, then it returns case1, else it returns case2.
  Behavior is similar to Java's: <b>return b ? case1 : case2;</b><br>
  If b==0 then case1 will not be evaluated, and vice versa.
  Example: IF(HEIGHT, 3/HEIGHT, 3) will make sure 3/HEIGHT does not cause division by zero.
  <br><br>
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultVars()"><!-- --></A><H3>
createDefaultVars</H3>
<PRE>
void <B>createDefaultVars</B>()</PRE>
<DL>
<DD>X, Y and PI variables are predefined and can be immediately used in the expression.
  Initial values of X and Y are 0. PI is 3.14159265358979
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="deleteVar(java.lang.String)"><!-- --></A><H3>
deleteVar</H3>
<PRE>
void <B>deleteVar</B>(java.lang.String&nbsp;varName)</PRE>
<DL>
<DD>deleteVar method deletes an existing variable from the list of available variables.
  If the variable does not exist, then deleteVar does nothing.
  <br><br>
  When a variable is deleted  Dirty flag is set to true so that next time
  the Evaluate function is called the expression will be reparsed.
  Variable name is not case sensitive.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="deleteFunc(java.lang.String)"><!-- --></A><H3>
deleteFunc</H3>
<PRE>
void <B>deleteFunc</B>(java.lang.String&nbsp;funcName)</PRE>
<DL>
<DD>deleteFunc method deletes an existing function from the list of available functions.
  If the function does not exist, deleteFunc does nothing.
  <br><br>
  When a function is deleted  Dirty flag is set to true so that next time the
  Evaluate function is called the expression will be reparsed.
  Function name is not case sensitive.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="deleteAllVars()"><!-- --></A><H3>
deleteAllVars</H3>
<PRE>
void <B>deleteAllVars</B>()</PRE>
<DL>
<DD>DeleteAllVars method deletes all variables from the list of available variables.
  <br><br>
  This action may be useful when number of unused variables is too high that
  causes performance to degrade.
  <br><br>
  When a variable is deleted Dirty flag is set to true so that next time the
  Evaluate function is called the expression will be reparsed.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="deleteAllFuncs()"><!-- --></A><H3>
deleteAllFuncs</H3>
<PRE>
void <B>deleteAllFuncs</B>()</PRE>
<DL>
<DD>DeleteAllFuncs method deletes all variables from the list of available functions.
  <br><br>
  This action may be useful when number of unused functions is too high that
  causes performance to degrade.
  <br><br>
  When a function is deleted Dirty flag is set to true so that next time the
  Evaluate function is called the expression will be reparsed.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getVariables()"><!-- --></A><H3>
getVariables</H3>
<PRE>
java.lang.String[] <B>getVariables</B>()</PRE>
<DL>
<DD>Returns the list of variables as an array of strings.
    Each element of the array is guaranteed not to be null.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getFunctions()"><!-- --></A><H3>
getFunctions</H3>
<PRE>
java.lang.String[] <B>getFunctions</B>()</PRE>
<DL>
<DD>Returns an array of functions declared for this parser.
    Elements of the array are guaranteed not to be null.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="freeParseTree()"><!-- --></A><H3>
freeParseTree</H3>
<PRE>
void <B>freeParseTree</B>()</PRE>
<DL>
<DD>FreeParseTree can be explicitly called to free the resources taken by the
  allocated Parse tree when an expression is parsed. FreeParseTree sets the Dirty
  flag to true so that next time the Evaluate function is called, expression will
  be parsed forming a new, valid parse tree to be evaluated.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isVariableUsed(java.lang.String)"><!-- --></A><H3>
isVariableUsed</H3>
<PRE>
boolean <B>isVariableUsed</B>(java.lang.String&nbsp;varName)
                       throws java.lang.Exception</PRE>
<DL>
<DD>Returns true if a variable with the name 'varName' is used in the current expression.
  Variable name is not case sensitive. Throws exception if expression is not parsed
  and cannot be parsed.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="isFuncUsed(java.lang.String)"><!-- --></A><H3>
isFuncUsed</H3>
<PRE>
boolean <B>isFuncUsed</B>(java.lang.String&nbsp;funcName)
                   throws java.lang.Exception</PRE>
<DL>
<DD>Returns true if a function with the name 'funcName' is used in the current expression.
  Function name is not case sensitive. Throws exception if expression is not parsed and cannot be parsed.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="GetVariablesUsed()"><!-- --></A><H3>
GetVariablesUsed</H3>
<PRE>
java.lang.String[] <B>GetVariablesUsed</B>()
                                    throws java.lang.Exception</PRE>
<DL>
<DD>Returns the list of variables used in the current expression as an array of Strings.
 Each element of the array is guaranteed not to be null.
 If variables are not defined ahead of time, then VariableResolver must have been set. 
 Otherwise, when an undefined variable is found in the expression, ParserException will be thrown.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Array of variable names that are currently defined for this parser instance.
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="isVariable(java.lang.String)"><!-- --></A><H3>
isVariable</H3>
<PRE>
boolean <B>isVariable</B>(java.lang.String&nbsp;varName)</PRE>
<DL>
<DD>Returns true if a variable with the name 'varName' is present in the current 
  variables list as a variable or constant.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isConstant(java.lang.String)"><!-- --></A><H3>
isConstant</H3>
<PRE>
boolean <B>isConstant</B>(java.lang.String&nbsp;constName)</PRE>
<DL>
<DD>Returns true if a constant with the name 'constName' is defined.
  If the given name is defined as a variable, but not a constant, this method
  returns false.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isFunction(java.lang.String)"><!-- --></A><H3>
isFunction</H3>
<PRE>
boolean <B>isFunction</B>(java.lang.String&nbsp;funcName)</PRE>
<DL>
<DD>Returns true if a function with the name 'funcName' is present in the current functions list.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="optimize()"><!-- --></A><H3>
optimize</H3>
<PRE>
void <B>optimize</B>()</PRE>
<DL>
<DD>Optimizes the parse tree by finding branches that evaluate to a constant and
  replacing them with a leaf representing the constant.
  Until the expression is changed and reparsed, further evaluation requests will be
  quicker.
  <br><br>
  If the same expression will not be evaluated repeatedly with varying
  values of parameters used in it, then optimization will not bring any gain,
  but will slow performance.
  <br><br>
  If OptimizationOn property is set to true, this method is called automatically when an
  evaluation is requested by calling Evaluate method or getValue() method.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setLocale(java.util.Locale)"><!-- --></A><H3>
setLocale</H3>
<PRE>
void <B>setLocale</B>(java.util.Locale&nbsp;l)</PRE>
<DL>
<DD>Sets the locale for the parser to use while constructing messages.
  Parser holds a static pool of translated messages mapped for each locale.
  When this method is called, it first checks to see if the resource bundle
  is already loaded in this pool. If it is loaded, it re-uses that pool.
  If it was not loaded before, it loads it, adds it to the pool and
  sets the specific bundle for this instance of the parser to use.
  This mechanism allows the parser instances in the same VM efficiently
  use different locales independent of each other. For example, if you
  instantiate 100 parsers to use US English locale and then another 200
  to use Chineese, then the parser will load the two resource bundles
  for once each and related instances will share the same ones.<br><br>
  When you set a locale, let's say "de_DE", you need to have a matching
  property file to be loaded by the parser,
  "com/bestcode/mathparser/mathparser_de_DE.properties".
  If such file is not found, the default version
  ("com/bestcode/mathparser/mathparser.properties"), which contains English
  messages will be loaded. The file IO is done once for each locale,
  not for each instance of the parser.<br><br>
  Messages may contain parameter placeholders. For example:
  "Variable {0} does not exist". You need to have your own messages translated
  accordingly.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLocale()"><!-- --></A><H3>
getLocale</H3>
<PRE>
java.util.Locale <B>getLocale</B>()</PRE>
<DL>
<DD>Returns the locale of this parser instance.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../com/bestcode/mathparser/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<A HREF="#main"><FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/bestcode/mathparser/IFunction.html" title="interface in com.bestcode.mathparser"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/bestcode/mathparser/IParameter.html" title="interface in com.bestcode.mathparser"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?com/bestcode/mathparser/IMathParser.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="IMathParser.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
